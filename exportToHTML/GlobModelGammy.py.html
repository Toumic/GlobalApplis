<html>
<head>
<title>GlobModelGammy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #008080; font-weight: bold;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GlobModelGammy.py</font>
</center></td></tr></table>
<pre><span class="s0"># Python 3.9 UTF-8</span>
<span class="s0"># Lundi 19 avril 2021 à 13h 57m (premières lignes)</span>
<span class="s0"># Lundi 3 mai 2021 (Développements diatoniques)</span>
<span class="s0">#</span>
<span class="s0"># Conçu par Vicenté Llavata Abreu | Vicenté Quantic | Toumic</span>
<span class="s0"># Module GlobModelGammy.py</span>

<span class="s0">&quot;&quot;&quot; Module d'application au traitement de la résultante clustérienne 
en une diatonie relative à la gamme_majeure naturelle musicale. 
    * L'aspect diatonique de la gamme_majeure:_ = Sur une octave de 12 notes 
    * L'aspect diatonique du tétracorde:_ = Sur l'éventail du tétra 
Il y a autant de notes que de modulations diatoniques et 
les ensembles fondamentaux n'ont pas les mêmes modulations 
Ce module trie les diatoniques afin d'un rassemblement fondamental 
sans exécuter le traitement des tonalités avec les signatures (b/#) 
Afin de faciliter le traitement, chaque entrée [1,2,3,4] devient [1,1,1,1] 
    Rajouté: Pour plusieurs tétracordes de même longueur 
        Une suite consécutive de zéros tient de famille diatonique 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">GlobGamFonds</span>

<span class="s1">glob_fond = GlobGamFonds</span>


<span class="s2">def </span><span class="s1">gammy():</span>
    <span class="s1">cluster, coupler, recoder = [], [], []</span>
    <span class="s1">diatonic_tetra = {</span><span class="s3">4</span><span class="s1">: [], </span><span class="s3">5</span><span class="s1">: [], </span><span class="s3">6</span><span class="s1">: [], </span><span class="s3">7</span><span class="s1">: [], </span><span class="s3">8</span><span class="s1">: [], </span><span class="s3">9</span><span class="s1">: []}</span>
    <span class="s1">diatonic_gamme = {</span><span class="s3">12</span><span class="s1">: []}</span>
    <span class="s1">module_gamme = []</span>
    <span class="s1">bineur_gamme = []</span>

    <span class="s0"># Chargement des fichiers</span>
    <span class="s2">def </span><span class="s1">lecteur():</span>
        <span class="s0"># Chargement Fichier.txt</span>
        <span class="s0">&quot;&quot;&quot;GlobDicTCord = Tétras uniques: 1234&quot;&quot;&quot;</span>
        <span class="s1">fil_cluster = open(</span><span class="s4">'globdicTcord.txt'</span><span class="s1">, </span><span class="s4">'r'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">fil_cluster:</span>
            <span class="s1">cluster.append(d)</span>
        <span class="s1">fil_cluster.close()</span>
        <span class="s4">&quot;&quot;&quot;GlobDicTCoup = Tétras couplés: 1234,0,5678&quot;&quot;&quot;</span>
        <span class="s1">fil_couple = open(</span><span class="s4">'globdicTcoup.txt'</span><span class="s1">, </span><span class="s4">'r'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">fil_couple:</span>
            <span class="s1">coupler.append(d)</span>
        <span class="s1">fil_couple.close()</span>
        <span class="s4">&quot;&quot;&quot;GlobDicTCode = Tétras codés:1234=#/b(1234)#/b(5678)&quot;&quot;&quot;</span>
        <span class="s1">fil_codage = open(</span><span class="s4">'globdicTcode.txt'</span><span class="s1">, </span><span class="s4">'r'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">fil_codage:</span>
            <span class="s1">recoder.append(d)</span>
        <span class="s1">fil_codage.close()</span>

    <span class="s4">&quot;&quot;&quot;CLUSTER GlobDicTCord = Tétras uniques: 1234 cluster[]&quot;&quot;&quot;</span>
    <span class="s4">&quot;&quot;&quot;COUPLER GlobDicTCoup = Tétras couplés: 1234,0,5678 coupler[]&quot;&quot;&quot;</span>
    <span class="s4">&quot;&quot;&quot;RECODER GlobDicTCode = Tétras codés:1234={[#/b(1234)][#/b(5678)]} recoder[]&quot;&quot;&quot;</span>
    <span class="s1">lecteur()</span>

    <span class="s0"># Définition diatonic_tetra tétra / gamme_majeure</span>
    <span class="s4">&quot;&quot;&quot;Cycle degrés tétras non signés&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">transpose(module):</span>
        <span class="s1">mirez, modes, binez1, binez2 = </span><span class="s4">''</span><span class="s1">, [], </span><span class="s4">''</span><span class="s1">, []</span>
        <span class="s1">ozo, ooo = len(module), list(module)</span>
        <span class="s2">if </span><span class="s1">ozo &lt; </span><span class="s3">12</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">range(ozo):</span>
                <span class="s1">ooo.insert(</span><span class="s3">0</span><span class="s1">, ooo.pop())</span>
                <span class="s1">mirez = </span><span class="s4">''</span><span class="s1">.join(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">ooo)</span>
                <span class="s1">modes.append(mirez)</span>
            <span class="s1">diatonic_tetra[ozo].append(modes)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">range(ozo):</span>
                <span class="s1">ooo.insert(</span><span class="s3">0</span><span class="s1">, ooo.pop())</span>
                <span class="s1">mirez = </span><span class="s4">''</span><span class="s1">.join(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">ooo)</span>
                <span class="s1">modes.append(mirez)</span>
            <span class="s2">for </span><span class="s1">mo </span><span class="s2">in </span><span class="s1">modes[-</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">int(mo) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">binez1 += </span><span class="s4">'1'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">binez1 += </span><span class="s4">'0'</span>
            <span class="s1">binez2.append(binez1)</span>
            <span class="s1">diatonic_gamme[ozo].append(modes)</span>
            <span class="s1">module_gamme.append(modes)</span>
            <span class="s1">bineur_gamme.append(binez2)</span>

    <span class="s0"># Origine tétra cluster[]</span>
    <span class="s4">&quot;&quot;&quot;Les tétras uniques: 1234&quot;&quot;&quot;</span>
    <span class="s1">col = [</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">clou </span><span class="s2">in </span><span class="s1">cluster:</span>
        <span class="s1">tr1 = str(clou[:len(clou) - </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">col[</span><span class="s3">0</span><span class="s1">] += </span><span class="s3">1</span>
        <span class="s1">transpose(tr1)</span>

    <span class="s0"># Fondamentales gammes coupler[]</span>
    <span class="s4">&quot;&quot;&quot;Les fondamentales sont plus légères 1234,0,5678&quot;&quot;&quot;</span>
    <span class="s1">col = [</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">clou </span><span class="s2">in </span><span class="s1">coupler:</span>
        <span class="s1">tr1 = str(clou[:len(clou) - </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">col[</span><span class="s3">0</span><span class="s1">] += </span><span class="s3">1</span>
        <span class="s1">transpose(tr1[:</span><span class="s3">12</span><span class="s1">])</span>

    <span class="s0"># Envoi Binariseur</span>
    <span class="s1">glob_fond.diatonic(module_gamme, bineur_gamme)</span>

    <span class="s0"># Tétracorde binaire recoder[]</span>
    <span class="s4">&quot;&quot;&quot;L'alternative tétracordique 1234=#/b(1234)#/b(5678)&quot;&quot;&quot;</span>
</pre>
</body>
</html>